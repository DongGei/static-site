{"relevantArticles":[{"articleTitle":"团队表 -多级团队设计","articleAbstractText":"团队表 -多级团队设计 user_team团队表 ，如果存在子团队 1.我们可以通过每一个团队字段加一个parentid （相当于一对多的关系） 2.还可以设置一个字段CodingNum,比如这样: //系统为了管理查询团队自动生成的有序编号 可以使用3位数代表一个层级 ，二级团队就是6位数 在代码中可以直接使用 like 009% 查询到它对应的所有子团队 优点： 如果是parentid 查询所有子团队需要多次sql查询 通过位数截取也可以查询到子团队的上级团队","articleStatus":0,"articlePermalink":"/articles/2023/11/15/1700033761710.html","articleImg1URL":"https://b3logfile.com/bing/20191116.jpg?imageView2/1/w/960/h/540/interlace/1/q/100"},{"articleTitle":"spring给静态成员注入 你试过吗?","articleAbstractText":"给静态成员注入 你试过吗? public class TempDataTransformUtilDto { @Autowired &nbsp; &nbsp;private static ICityCascadeService cityCascadeService; &nbsp; &nbsp;private static CstShareEmpMapper cstShareEmpMapper; &nbsp; &nbsp;private static PubUserInfoMapper pubUserInfoMapper; }  如果ICityCascadeService 通过@Service 注入的，@Autowired在这里是不管用的。 在使用时 会报错NullPointer !!!! 理解： 1.类成员的初始化较早，并不需要依赖实例的创建，所以这个时候Spring容器可能都还没\u201c出生\u201d，谈何依赖注入呢？ 2.当类加载器加载静态变量时，Spring的上下文环境还没有被加载。 3.AutowiredAnnotationBeanPostProcessor类源码，扫描Class类需要注入的元....","articleStatus":0,"articlePermalink":"/articles/2023/11/15/1700033835081.html","articleImg1URL":"https://b3logfile.com/bing/20180114.jpg?imageView2/1/w/960/h/540/interlace/1/q/100"},{"articleTitle":"怎么保证数据唯一性","articleAbstractText":"悲观锁 unique索引","articleStatus":0,"articlePermalink":"/articles/2023/11/15/1700033502345.html","articleImg1URL":"https://b3logfile.com/bing/20190731.jpg?imageView2/1/w/960/h/540/interlace/1/q/100"},{"articleTitle":"老项目迁移方法","articleAbstractText":"老项目迁移方法 需求： **因某个模块MySQL表结构、表关系 错乱复杂，**而且其他模块的代码也在操作这个模块的数据库 耦合严重 导致Web工程代码紊乱、不易理解、性能低下， 故在 系统由A JavaWeb工程迁移至B工程 时，重构MySQL表结构、表关系。 涉及到了数据库的重新设计和使用，需要考虑数据库的使用 采取的方法： 增删改查： 一期 是 全部的****写入 修改 删除 新旧表同时操作，新功能读取新表，** **旧功能因为太多，没法改 还是走旧表查询 二期是把所有的 其它模块读取旧表的全部改成读取新表，这个模块旧功能也走新表查询 然后把 旧表在数据库完全删除 写代码的逻辑是这样： 红色：由Web工程（SSH + JSP）重构至Service工程（SSM + VUE），此为模块核心业务逻辑。 黄色：接口定义-新表化改造（出入参改造），为前后端对接联调作准备，避免多次对接。 **绿色：进行全域新表双写的插入（增加、删除、修改 均处理完毕）。","articleStatus":0,"articlePermalink":"/articles/2023/11/15/1700033784334.html","articleImg1URL":"https://b3logfile.com/bing/20200122.jpg?imageView2/1/w/960/h/540/interlace/1/q/100"},{"articleTitle":"java面经总结","articleAbstractText":"java基础面 1.数组和链表结构简单对比？（ArrayList和linkedList） **数组是一段连续的空间。 大小固定 可能大小不够用或者有浪费 ** 数组查询比较方便，根据下标就可以直接找到元素，时间复杂度O(1)；增加和删除比较复杂，需要移动操作数所在位置后的所有数据，时间复杂度为O(N) 链表是使用是一种物理存储单元上非连续，非顺序的存储结构 插入、删除数据比较方便,时间复杂度O(1)；查询必须从头开始找起，十分麻烦，时间复杂度O(N) LinkedList 插入到中间位置并不快 比ArrayList还慢 因为要先遍历 除了头部插入 LinkedList快 其他都不如ArrayList  因为一个node里面有前后指针 所以占用内存多 2.类的初始化 对象实例化 类的初始化： **是完成程序执行前的准备工作。在这个阶段，**静态的（变量，方法，代码块）会被执行。同时在会开辟一块存储空间用来存放静态的数据。类初始化只在类加载的时候执行一次 类的实例化（实例化对象）： 是指创建一个对象的过程。这个过程中会在堆中开辟内存，将一些****非静态的方法，变量存放在里面。在程序执行的....","articleStatus":0,"articlePermalink":"/articles/2023/11/14/1699951852050.html","articleImg1URL":"https://b3logfile.com/file/2023/11/solo-fetchupload-9990781929491349813-TANyTLr.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100"}]}