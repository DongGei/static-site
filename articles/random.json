{"randomArticles":[{"articleTitle":"spring给静态成员注入 你试过吗?","articleAbstractText":"给静态成员注入 你试过吗? public class TempDataTransformUtilDto { @Autowired &nbsp; &nbsp;private static ICityCascadeService cityCascadeService; &nbsp; &nbsp;private static CstShareEmpMapper cstShareEmpMapper; &nbsp; &nbsp;private static PubUserInfoMapper pubUserInfoMapper; }  如果ICityCascadeService 通过@Service 注入的，@Autowired在这里是不管用的。 在使用时 会报错NullPointer !!!! 理解： 1.类成员的初始化较早，并不需要依赖实例的创建，所以这个时候Spring容器可能都还没\u201c出生\u201d，谈何依赖注入呢？ 2.当类加载器加载静态变量时，Spring的上下文环境还没有被加载。 3.AutowiredAnnotationBeanPostProcessor类源码，扫描Class类需要注入的元....","articleStatus":0,"articlePermalink":"/articles/2023/11/15/1700033835081.html","articleImg1URL":"https://b3logfile.com/bing/20180114.jpg?imageView2/1/w/960/h/540/interlace/1/q/100"},{"articleTitle":"java多线程","articleAbstractText":"JavaThread 概述 Thread，英文单词，名词、动词，作名词时意思是\u201c线；螺纹；思路；衣服；线状物；玻璃纤维；路线\u201d，java多线程。 进程是系统运行程序的基本单位，线程是比进程更小、更轻量级的执行单位，每个进程都拥有自己的一块内存空间和变量资源等，然而同一个进程下的多个线程则共享数据和资源，所以不管线程的创建和销毁工作，还是在线程之间切换工作，都要比进程更加轻量级、消耗系统资源更少。 多线程在多个cpu的机器上可以实现。如果只是单cpu，只是让我们看起来是多线程的。实际上运行的是靠cup的调度。而不是同时去执行的。 在jvm中 每一个线程都有自己的java虚拟机栈，本地方法栈，程序计数器。而对应的所有线程共享堆内存和元空间（以前版本也叫方法区）。与上一段文字进程和线程的关系对应。 创建多线程 声明一个Thread类的子类，子类中重写Thread类的run方法。Thread也实现了runnable接口 声明一个实现Runnable接口的类，类中实现run方法。 声明一个实现Callable接口的类（在初级阶段不需要太了解） 推荐使用runnable接口 **我认为最主要的原因....","articleStatus":0,"articlePermalink":"/articles/2023/11/14/1699951927724.html","articleImg1URL":"https://b3logfile.com/file/2023/11/solo-fetchupload-4795024217609908277-atSRtLT.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100"},{"articleTitle":"团队表 -多级团队设计","articleAbstractText":"团队表 -多级团队设计 user_team团队表 ，如果存在子团队 1.我们可以通过每一个团队字段加一个parentid （相当于一对多的关系） 2.还可以设置一个字段CodingNum,比如这样: //系统为了管理查询团队自动生成的有序编号 可以使用3位数代表一个层级 ，二级团队就是6位数 在代码中可以直接使用 like 009% 查询到它对应的所有子团队 优点： 如果是parentid 查询所有子团队需要多次sql查询 通过位数截取也可以查询到子团队的上级团队","articleStatus":0,"articlePermalink":"/articles/2023/11/15/1700033761710.html","articleImg1URL":"https://b3logfile.com/bing/20191116.jpg?imageView2/1/w/960/h/540/interlace/1/q/100"}]}